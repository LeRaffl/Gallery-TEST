<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <title>BEV Trajectories · Gallery</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --maxw: 1100px; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 0; background: #0b101b; color: #e9eef2; }
    header { max-width: var(--maxw); margin: 18px auto 8px; padding: 0 10px; display: flex; justify-content: space-between; align-items: baseline; }
    header h1 { font-size: 22px; margin: 0; }
    .badge { padding: 4px 10px; border-radius: 999px; background: #0e1a34; color: #b4c2d8; border: 1px solid #1f2a44; font-size: 12px; }

    /* Tabs UI */
    .tabs{max-width:var(--maxw);margin:8px auto 0;padding:0 10px;display:flex;gap:10px;flex-wrap:wrap}
    .tablink{padding:8px 12px;border:1px solid #1f2a44;border-radius:10px;background:#101a33;color:#e9eef2;text-decoration:none}
    .tablink.active{background:#e9eef2;color:#0b0c10}
    .tab{display:none}
    .tab.active{display:block}

    /* Card */
    .card { max-width: var(--maxw); margin: 12px auto; padding: 16px; border: 1px dashed #2a3654; border-radius: 12px; background:#0f1525 }

    /* Thresholds table tweaks */
    #tab-thresholds table { width:100%; border-collapse: collapse; }
    #tab-thresholds th, #tab-thresholds td { padding: 10px 12px; border-bottom: 1px solid #1f2a44; }
    #tab-thresholds thead th { font-weight: 750; letter-spacing: 0.02em; }
    #tab-thresholds th.sortable { cursor: pointer; position: relative; user-select: none; }
    #tab-thresholds th.sortable::after { content: " ↕"; opacity: 0.6; font-size: 0.9em; }
    #tab-thresholds th.sortable.asc::after { content: " ↑"; }
    #tab-thresholds th.sortable.desc::after { content: " ↓"; }
    #tab-thresholds td.num, #tab-thresholds th.num { width: 56px; text-align: right; color: #9fb3d1; }

    /* Placeholder gallery styles */
    .page { max-width: var(--maxw); margin: 12px auto; padding: 0 10px; }
    .muted { color:#9fb3d1; font-size: 13px; }
  </style>
</head>
<body>
  <header>
    <h1>BEV Trajectories · Gallery</h1>
    <span class="badge" id="chartsBadge">Showing n charts</span>
  </header>

  <nav class="tabs">
    <a href="#gallery" class="tablink active">Galerie</a>
    <a href="#thresholds" class="tablink">Thresholds</a>
    <a href="#durations" class="tablink">Durations</a>
  </nav>

  <section id="tab-gallery" class="tab active">
    <div class="page">
      <p class="muted">Hier liegt deine bestehende Galerie. Diese Demo-Datei enthält nur die neuen Tabs-Features.</p>
    </div>
  </section>

  <section id="tab-thresholds" class="tab">
    <div class="page">
      <h2 style="margin:6px 0 12px">Thresholds (Test, Jahre)</h2>
    </div>
    <div id="thresholdsMount" class="card">
      Lädt <code>params.csv</code> und berechnet <b>20% / 50% / 80%</b> live im Browser.
    </div>
  </section>

  <section id="tab-durations" class="tab">
    <div class="page">
      <h2 style="margin:6px 0 12px">Durations</h2>
    </div>
    <div id="durationsMount" class="card">Platzhalter – folgt.</div>
  </section>

  <script>
    // ---- Tabs: robust hash routing + click intercept ----
    function activateTabByHash(){
      const hash = location.hash || '#gallery';
      const id = hash.replace('#','');
      const tabs = document.querySelectorAll('.tab');
      const links = document.querySelectorAll('.tablink');
      tabs.forEach(el => { el.classList.remove('active'); el.setAttribute('hidden',''); });
      links.forEach(a => a.classList.remove('active'));
      const tab = document.getElementById('tab-' + id) || document.getElementById('tab-gallery');
      const link = document.querySelector('.tablink[href="#' + id + '"]') || document.querySelector('.tablink[href="#gallery"]');
      if (tab) { tab.classList.add('active'); tab.removeAttribute('hidden'); }
      if (link) link.classList.add('active');
    }
    window.addEventListener('hashchange', activateTabByHash);
    document.addEventListener('DOMContentLoaded', () => {
      document.querySelectorAll('.tablink').forEach(a => {
        a.addEventListener('click', (e) => {
          e.preventDefault();
          const href = a.getAttribute('href') || '#gallery';
          history.replaceState(null, '', href);
          activateTabByHash();
        });
      });
      activateTabByHash();
    });

    // ---- CSV Parser (',' oder ';'), BOM-fest ----
    function parseCSV(text) {
      const raw = (text || '').trim();
      if (!raw) return [];
      const first = raw.split(/\r?\n/)[0] || '';
      const delimiter = (first.match(/;/g)||[]).length > (first.match(/,/g)||[]).length ? ';' : ',';
      const lines = raw.split(/\r?\n/);
      const header = (lines.shift() || '').split(delimiter).map(h => h.replace(/^\uFEFF?/,'').trim());
      return lines.filter(Boolean).map(line => {
        const cols = line.split(new RegExp(`${delimiter}(?=(?:[^"]*"[^"]*")*[^"]*$)`));
        const o = {};
        header.forEach((h,i)=> o[h] = (cols[i]||'').replace(/^\"|\"$/g,'').trim());
        return o;
      });
    }

    // ---- Helpers: numbers + YEARS handling ----
    function normNumber(x) {
      if (x == null) return NaN;
      const s = String(x).trim().replace(/\u00A0/g,' ').replace(',', '.'); // decimal comma -> dot
      const n = Number(s);
      return isFinite(n) ? n : NaN;
    }

    // Convert decimal YEARS index to a calendar date if baseline is supplied.
    function yearsIndexToDate(xYears, baseline_date, baseline_year) {
      if (!isFinite(xYears)) return "";
      let base;
      if (baseline_date && /^\d{4}-\d{2}-\d{2}$/.test(String(baseline_date))) {
        base = new Date(String(baseline_date) + 'T00:00:00Z');
      } else if (isFinite(normNumber(baseline_year))) {
        base = new Date(String(Math.round(normNumber(baseline_year))) + '-01-01T00:00:00Z');
      } else {
        return ""; // no baseline to map to calendar date
      }
      if (isNaN(base)) return "";
      const years = Math.floor(xYears);
      const frac = xYears - years;
      const months = Math.round(frac * 12);
      const d = new Date(Date.UTC(base.getUTCFullYear() + years, base.getUTCMonth() + months, 1));
      d.setUTCDate(15);
      return d.toISOString().slice(0,10);
    }

    // ---- Model inversion in YEARS ----
    // y = 1 - exp( v1 * (x - (t0 - 1))^v2 ), where x, t0 are in YEARS
    // x(y) = (t0 - 1) + [ ln(1 - y) / v1 ]^(1/v2)
    function inv_x_years(y, v1, v2, t0_years) {
      if (!(y > 0 && y < 1)) return {x:NaN, why:"y∉(0,1)"};
      const v1n = normNumber(v1), v2n = normNumber(v2), t0n = normNumber(t0_years);
      if (!isFinite(v1n) || !isFinite(v2n) || !isFinite(t0n)) return {x:NaN, why:"v1/v2/t0 nicht numerisch"};
      if (v2n === 0) return {x:NaN, why:"v2=0"};
      if (v1n >= 0) return {x:NaN, why:"v1 muss < 0 sein"};
      const num = Math.log(1 - y) / v1n; // negative / negative -> positive
      if (!(num > 0)) return {x:NaN, why:"ln(1-y)/v1 ≤ 0"};
      const x = (t0n - 1) + Math.pow(num, 1 / v2n);
      return {x, why:null};
    }

    // ---- Thresholds with sorting & row numbers (YEARS-based) ----
    function renderThresholdsYears(csvText){
      const rows = parseCSV(csvText);
      const mount = document.getElementById('thresholdsMount');
      if (!rows.length) { mount.textContent = 'params.csv enthält keine Datenzeilen.'; return; }

      let data = rows.map(r => {
        const v1 = normNumber(r.v1);
        const v2 = normNumber(r.v2);
        const t0y = normNumber(r.t0); // t0 in YEARS (decimal)
        const baseDate = r.baseline_date || "";
        const baseYear = normNumber(r.baseline_year);

        const r20 = inv_x_years(0.2, v1, v2, t0y);
        const r50 = inv_x_years(0.5, v1, v2, t0y);
        const r80 = inv_x_years(0.8, v1, v2, t0y);

        const fmt = (res) => {
          if (!res || !isFinite(res.x)) return {text:"—", title: res?.why || "keine Lösung"};
          const d = yearsIndexToDate(res.x, baseDate, baseYear);
          return {text: d || res.x.toFixed(2), title: d ? "" : "kein baseline, zeige Jahre"};
        };
        const f20 = fmt(r20), f50 = fmt(r50), f80 = fmt(r80);

        return {
          country: r.country || "", variant: r.variant || "",
          val20: f20.text, tip20: f20.title,
          val50: f50.text, tip50: f50.title,
          val80: f80.text, tip80: f80.title,
          model_date: r.model_date || "", source: r.source || ""
        };
      });

      function isoOrVal(s) {
        const t = Date.parse(s);
        if (!isNaN(t)) return t;
        const n = parseFloat(String(s).replace(',','.'));
        return isFinite(n) ? n : (s||'').toString().toLowerCase();
      }
      let sortKey = "val80", sortAsc = true; // default: earliest 80%
      function doSort() {
        if (!sortKey) return;
        data.sort((a,b) => {
          const va = isoOrVal(a[sortKey]); const vb = isoOrVal(b[sortKey]);
          if (va < vb) return sortAsc ? -1 : 1;
          if (va > vb) return sortAsc ? 1 : -1;
          return 0;
        });
      }
      function renderTable() {
        doSort();
        const header = `
          <thead>
            <tr>
              <th class="num">#</th>
              <th class="sortable" data-key="country">Land</th>
              <th class="sortable" data-key="variant">Variante</th>
              <th class="sortable" data-key="val20">20%</th>
              <th class="sortable" data-key="val50">50%</th>
              <th class="sortable" data-key="val80">80%</th>
              <th class="sortable" data-key="model_date">Modelldatum</th>
              <th>Quelle</th>
            </tr>
          </thead>`;
        const body = `<tbody>
          ${data.map((r,i)=>`
            <tr>
              <td class="num">${i+1}</td>
              <td>${r.country}</td>
              <td>${r.variant}</td>
              <td title="${r.tip20}">${r.val20}</td>
              <td title="${r.tip50}">${r.val50}</td>
              <td title="${r.tip80}">${r.val80}</td>
              <td>${r.model_date}</td>
              <td>${r.source}</td>
            </tr>`).join('')}
        </tbody>`;
        mount.innerHTML = `<table class="table">${header}${body}</table>`;
        const ths = mount.querySelectorAll('th.sortable');
        ths.forEach(th => {
          th.classList.remove('asc','desc');
          if (th.getAttribute('data-key') === sortKey) th.classList.add(sortAsc ? 'asc' : 'desc');
          th.onclick = () => {
            const key = th.getAttribute('data-key');
            if (sortKey === key) sortAsc = !sortAsc; else { sortKey = key; sortAsc = true; }
            renderTable();
          };
        });
      }
      renderTable();
    }

    // Boot thresholds
    function bootThresholds(){
      const urls = ['./params.csv','params.csv'];
      (function next(i){
        if (i>=urls.length) { const m=document.getElementById('thresholdsMount'); if(m) m.textContent='Konnte params.csv nicht laden.'; return; }
        fetch(urls[i], { cache:'no-store' })
          .then(r => r.ok ? r.text() : Promise.reject(new Error('HTTP '+r.status)))
          .then(text => renderThresholdsYears(text))
          .catch(()=> next(i+1));
      })(0);
    }
    document.addEventListener('DOMContentLoaded', bootThresholds);
  </script>
</body>
</html>
